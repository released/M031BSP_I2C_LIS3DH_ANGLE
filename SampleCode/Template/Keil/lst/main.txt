; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\main.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\main.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M031\Include -I..\..\..\Library\StdDriver\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 --omf_browse=.\obj\main.crf ..\main.c]
                          THUMB

                          AREA ||i.GPIO_Init||, CODE, READONLY, ALIGN=2

                  GPIO_Init PROC
;;;71     
;;;72     void GPIO_Init (void)
000000  b510              PUSH     {r4,lr}
;;;73     {
;;;74         GPIO_SetMode(PB, BIT14, GPIO_MODE_OUTPUT);
000002  2201              MOVS     r2,#1
000004  0391              LSLS     r1,r2,#14
000006  4802              LDR      r0,|L1.16|
000008  f7fffffe          BL       GPIO_SetMode
;;;75     }
00000c  bd10              POP      {r4,pc}
;;;76     
                          ENDP

00000e  0000              DCW      0x0000
                  |L1.16|
                          DCD      0x40004040

                          AREA ||i.I2C0_Init||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  I2C0_Init PROC
;;;45     
;;;46     void I2C0_Init(void)	//PC1 : SCL , PC0 : SDA
000000  b570              PUSH     {r4-r6,lr}
;;;47     {
;;;48     	uint16_t i = 0xFFF;
000002  4c12              LDR      r4,|L2.76|
;;;49         GPIO_SetMode(PC, BIT4, GPIO_MODE_OUTPUT);	//SA0 (PC4)
000004  2201              MOVS     r2,#1
000006  2110              MOVS     r1,#0x10
000008  4811              LDR      r0,|L2.80|
00000a  f7fffffe          BL       GPIO_SetMode
;;;50     	PC4 = 1;
00000e  4d11              LDR      r5,|L2.84|
000010  2001              MOVS     r0,#1
000012  6128              STR      r0,[r5,#0x10]
                  |L2.20|
;;;51     
;;;52     	while(i--);	//delay
000014  4620              MOV      r0,r4
000016  1e64              SUBS     r4,r4,#1
000018  b2a4              UXTH     r4,r4
00001a  2800              CMP      r0,#0
00001c  d1fa              BNE      |L2.20|
;;;53     
;;;54     	#if defined (I2C_ANALOG)
;;;55         GPIO_SetMode(PC, BIT1, GPIO_MODE_OUTPUT);
;;;56         GPIO_SetMode(PC, BIT0, GPIO_MODE_OUTPUT);	
;;;57     
;;;58     	I2C_ANALOG_GPIO_Init();
;;;59     	
;;;60     	#else
;;;61     
;;;62         /* Open I2C module and set bus clock */
;;;63         I2C_Open(I2C0, LIS3DH_I2C_SPEED);
00001e  4c0f              LDR      r4,|L2.92|
000020  490d              LDR      r1,|L2.88|
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       I2C_Open
;;;64     
;;;65         I2C_SetSlaveAddr(I2C0, 0, LIS3DH_ADDRESS, 0);   /* Slave Address : 0011001b */
000028  6929              LDR      r1,[r5,#0x10]
00002a  2018              MOVS     r0,#0x18
00002c  4301              ORRS     r1,r1,r0
00002e  b2ca              UXTB     r2,r1
000030  2300              MOVS     r3,#0
000032  4619              MOV      r1,r3
000034  4620              MOV      r0,r4
000036  f7fffffe          BL       I2C_SetSlaveAddr
;;;66     
;;;67         /* Get I2C0 Bus Clock */
;;;68         printf("I2C clock %d Hz\n", I2C_GetBusClockFreq(I2C0));
00003a  4620              MOV      r0,r4
00003c  f7fffffe          BL       I2C_GetBusClockFreq
000040  4601              MOV      r1,r0
000042  a007              ADR      r0,|L2.96|
000044  f7fffffe          BL       __2printf
;;;69     	#endif	
;;;70     }
000048  bd70              POP      {r4-r6,pc}
;;;71     
                          ENDP

00004a  0000              DCW      0x0000
                  |L2.76|
                          DCD      0x00000fff
                  |L2.80|
                          DCD      0x40004080
                  |L2.84|
                          DCD      0x40004880
                  |L2.88|
                          DCD      0x000186a0
                  |L2.92|
                          DCD      0x40080000
                  |L2.96|
000060  49324320          DCB      "I2C clock %d Hz\n",0
000064  636c6f63
000068  6b202564
00006c  20487a0a
000070  00      
000071  00                DCB      0
000072  00                DCB      0
000073  00                DCB      0

                          AREA ||i.SYS_Init||, CODE, READONLY, ALIGN=2

                  SYS_Init PROC
;;;135    
;;;136    void SYS_Init(void)
000000  b570              PUSH     {r4-r6,lr}
000002  2059              MOVS     r0,#0x59
000004  4c1f              LDR      r4,|L3.132|
000006  2116              MOVS     r1,#0x16
000008  2288              MOVS     r2,#0x88
                  |L3.10|
00000a  6020              STR      r0,[r4,#0]
00000c  6021              STR      r1,[r4,#0]
00000e  6022              STR      r2,[r4,#0]
000010  6823              LDR      r3,[r4,#0]
000012  2b00              CMP      r3,#0
000014  d0f9              BEQ      |L3.10|
;;;137    {
;;;138        /* Unlock protected registers */
;;;139        SYS_UnlockReg();
;;;140    
;;;141        /* Enable HIRC clock (Internal RC 48MHz) */
;;;142        CLK_EnableXtalRC(CLK_PWRCTL_HIRCEN_Msk);
000016  2004              MOVS     r0,#4
000018  f7fffffe          BL       CLK_EnableXtalRC
;;;143    //    CLK_EnableXtalRC(CLK_PWRCTL_HXTEN_Msk);
;;;144    	
;;;145        /* Wait for HIRC clock ready */
;;;146        CLK_WaitClockReady(CLK_STATUS_HIRCSTB_Msk);
00001c  2010              MOVS     r0,#0x10
00001e  f7fffffe          BL       CLK_WaitClockReady
;;;147    //    CLK_WaitClockReady(CLK_STATUS_HXTSTB_Msk);
;;;148    	
;;;149        /* Select HCLK clock source as HIRC and HCLK source divider as 1 */
;;;150        CLK_SetHCLK(CLK_CLKSEL0_HCLKSEL_HIRC, CLK_CLKDIV0_HCLK(1));
000022  2100              MOVS     r1,#0
000024  2007              MOVS     r0,#7
000026  f7fffffe          BL       CLK_SetHCLK
;;;151    //    CLK_SetHCLK(CLK_CLKSEL0_HCLKSEL_PLL, CLK_CLKDIV0_HCLK(1));
;;;152    	
;;;153        /* Enable UART0 clock */
;;;154        CLK_EnableModuleClock(UART0_MODULE);
00002a  4d17              LDR      r5,|L3.136|
00002c  4628              MOV      r0,r5
00002e  f7fffffe          BL       CLK_EnableModuleClock
;;;155        CLK_SetModuleClock(UART0_MODULE, CLK_CLKSEL1_UART0SEL_PCLK0, CLK_CLKDIV0_UART0(1));
000032  2101              MOVS     r1,#1
000034  2200              MOVS     r2,#0
000036  0689              LSLS     r1,r1,#26
000038  4628              MOV      r0,r5
00003a  f7fffffe          BL       CLK_SetModuleClock
;;;156    	
;;;157        CLK_EnableModuleClock(TMR3_MODULE);
00003e  4d13              LDR      r5,|L3.140|
000040  4628              MOV      r0,r5
000042  f7fffffe          BL       CLK_EnableModuleClock
;;;158        CLK_SetModuleClock(TMR3_MODULE, CLK_CLKSEL1_TMR3SEL_PCLK1, 0);
000046  2101              MOVS     r1,#1
000048  2200              MOVS     r2,#0
00004a  0549              LSLS     r1,r1,#21
00004c  4628              MOV      r0,r5
00004e  f7fffffe          BL       CLK_SetModuleClock
;;;159    	
;;;160        CLK_EnableModuleClock(I2C0_MODULE);
000052  480c              LDR      r0,|L3.132|
000054  38f8              SUBS     r0,r0,#0xf8
000056  f7fffffe          BL       CLK_EnableModuleClock
;;;161    
;;;162        /* Update System Core Clock */
;;;163        SystemCoreClockUpdate();
00005a  f7fffffe          BL       SystemCoreClockUpdate
;;;164    
;;;165        /* Set PB multi-function pins for UART0 RXD=PB.12 and TXD=PB.13 */
;;;166        SYS->GPB_MFPH = (SYS->GPB_MFPH & ~(SYS_GPB_MFPH_PB12MFP_Msk | SYS_GPB_MFPH_PB13MFP_Msk))    |       \
00005e  07a8              LSLS     r0,r5,#30
000060  6bc1              LDR      r1,[r0,#0x3c]
000062  22ff              MOVS     r2,#0xff
000064  0412              LSLS     r2,r2,#16
000066  4391              BICS     r1,r1,r2
000068  2233              MOVS     r2,#0x33
00006a  0452              LSLS     r2,r2,#17
00006c  1889              ADDS     r1,r1,r2
00006e  63c1              STR      r1,[r0,#0x3c]
;;;167                        (SYS_GPB_MFPH_PB12MFP_UART0_RXD | SYS_GPB_MFPH_PB13MFP_UART0_TXD);
;;;168    
;;;169    	#if !defined (I2C_ANALOG)
;;;170    
;;;171        /* Set I2C0 multi-function pins */
;;;172        SYS->GPC_MFPL = (SYS->GPC_MFPL & ~(SYS_GPC_MFPL_PC1MFP_Msk | SYS_GPC_MFPL_PC0MFP_Msk)) |
000070  4804              LDR      r0,|L3.132|
000072  38c0              SUBS     r0,r0,#0xc0
000074  6801              LDR      r1,[r0,#0]
000076  0a09              LSRS     r1,r1,#8
000078  0209              LSLS     r1,r1,#8
00007a  3199              ADDS     r1,r1,#0x99
00007c  6001              STR      r1,[r0,#0]
00007e  2000              MOVS     r0,#0
000080  6020              STR      r0,[r4,#0]
;;;173                        (SYS_GPC_MFPL_PC0MFP_I2C0_SDA | SYS_GPC_MFPL_PC1MFP_I2C0_SCL);
;;;174    	#endif
;;;175    
;;;176        /* Lock protected registers */
;;;177        SYS_LockReg();
;;;178    }
000082  bd70              POP      {r4-r6,pc}
;;;179    
                          ENDP

                  |L3.132|
                          DCD      0x40000100
                  |L3.136|
                          DCD      0x5f803d10
                  |L3.140|
                          DCD      0x5f400005

                          AREA ||i.TIMER3_Init||, CODE, READONLY, ALIGN=2

                  TIMER3_Init PROC
;;;110    
;;;111    void TIMER3_Init(void)
000000  b510              PUSH     {r4,lr}
;;;112    {
;;;113        TIMER_Open(TIMER3, TIMER_PERIODIC_MODE, 1000);
000002  4c0a              LDR      r4,|L4.44|
000004  227d              MOVS     r2,#0x7d
000006  2101              MOVS     r1,#1
000008  00d2              LSLS     r2,r2,#3
00000a  06c9              LSLS     r1,r1,#27
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       TIMER_Open
000012  6820              LDR      r0,[r4,#0]
000014  0621              LSLS     r1,r4,#24
000016  4308              ORRS     r0,r0,r1
000018  6020              STR      r0,[r4,#0]
00001a  1488              ASRS     r0,r1,#18
00001c  4904              LDR      r1,|L4.48|
00001e  6008              STR      r0,[r1,#0]
000020  6820              LDR      r0,[r4,#0]
000022  0589              LSLS     r1,r1,#22
000024  4308              ORRS     r0,r0,r1
000026  6020              STR      r0,[r4,#0]
;;;114        TIMER_EnableInt(TIMER3);
;;;115        NVIC_EnableIRQ(TMR3_IRQn);	
;;;116        TIMER_Start(TIMER3);
;;;117    }
000028  bd10              POP      {r4,pc}
;;;118    
                          ENDP

00002a  0000              DCW      0x0000
                  |L4.44|
                          DCD      0x40051020
                  |L4.48|
                          DCD      0xe000e100

                          AREA ||i.TMR3_IRQHandler||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  TMR3_IRQHandler PROC
;;;76     
;;;77     void TMR3_IRQHandler(void)
000000  b570              PUSH     {r4-r6,lr}
000002  491b              LDR      r1,|L5.112|
000004  6888              LDR      r0,[r1,#8]
000006  07c0              LSLS     r0,r0,#31
000008  0fc0              LSRS     r0,r0,#31
;;;78     {
00000a  d030              BEQ      |L5.110|
00000c  2201              MOVS     r2,#1
00000e  608a              STR      r2,[r1,#8]
;;;79     	static uint32_t LOG = 0;
;;;80     	static uint16_t CNT = 0;
;;;81     	static uint16_t CNT_SWITCH = 0;
;;;82     	uint8_t data = 0;
;;;83     	
;;;84         if(TIMER_GetIntFlag(TIMER3) == 1)
;;;85         {
;;;86             TIMER_ClearIntFlag(TIMER3);
;;;87     	
;;;88     		if (CNT++ >= 1000)
000010  4918              LDR      r1,|L5.116|
000012  247d              MOVS     r4,#0x7d
000014  8808              LDRH     r0,[r1,#0]  ; CNT
000016  00e4              LSLS     r4,r4,#3
000018  1c43              ADDS     r3,r0,#1
00001a  800b              STRH     r3,[r1,#0]
00001c  2300              MOVS     r3,#0
00001e  42a0              CMP      r0,r4
000020  d304              BCC      |L5.44|
;;;89     		{		
;;;90     			CNT = 0;
;;;91     //        	printf("%s : %4d\r\n",__FUNCTION__,LOG++);
;;;92     
;;;93     //			convertDecToBin(LIS3DH_ADDRESS);
;;;94     //			printf("\r\n");
;;;95     			PB14 ^= 1;
000022  4815              LDR      r0,|L5.120|
000024  800b              STRH     r3,[r1,#0]            ;90
000026  6b84              LDR      r4,[r0,#0x38]
000028  4054              EORS     r4,r4,r2
00002a  6384              STR      r4,[r0,#0x38]
                  |L5.44|
;;;96     		}
;;;97     
;;;98     		if (CNT_SWITCH++ >= 10000)
00002c  8848              LDRH     r0,[r1,#2]  ; CNT_SWITCH
00002e  1c44              ADDS     r4,r0,#1
000030  804c              STRH     r4,[r1,#2]
000032  4c12              LDR      r4,|L5.124|
000034  42a0              CMP      r0,r4
000036  d31a              BCC      |L5.110|
;;;99     		{		
;;;100    			CNT_SWITCH = 0;
;;;101    			FlagSwitch ^= 1;
000038  4811              LDR      r0,|L5.128|
00003a  804b              STRH     r3,[r1,#2]            ;100
00003c  7803              LDRB     r3,[r0,#0]  ; FlagSwitch
00003e  4053              EORS     r3,r3,r2
000040  7003              STRB     r3,[r0,#0]
;;;102    
;;;103            	printf("%s : %4d\r\n",__FUNCTION__,LOG++);
000042  684a              LDR      r2,[r1,#4]  ; LOG
000044  1c50              ADDS     r0,r2,#1
000046  6048              STR      r0,[r1,#4]  ; LOG
000048  490e              LDR      r1,|L5.132|
00004a  a00f              ADR      r0,|L5.136|
00004c  f7fffffe          BL       __2printf
;;;104            	printf("addr : 0x%2X\r\n",LIS3DH_ADDRESS);			
000050  4d09              LDR      r5,|L5.120|
000052  3540              ADDS     r5,r5,#0x40
000054  6929              LDR      r1,[r5,#0x10]
000056  2418              MOVS     r4,#0x18
000058  4321              ORRS     r1,r1,r4
00005a  a00e              ADR      r0,|L5.148|
00005c  f7fffffe          BL       __2printf
;;;105    			convertDecToBin(LIS3DH_ADDRESS);
000060  6928              LDR      r0,[r5,#0x10]
000062  4320              ORRS     r0,r0,r4
000064  f7fffffe          BL       convertDecToBin
;;;106    			printf("\r\n");			
000068  a009              ADR      r0,|L5.144|
00006a  f7fffffe          BL       __2printf
                  |L5.110|
;;;107    		}		
;;;108        }
;;;109    }
00006e  bd70              POP      {r4-r6,pc}
;;;110    
                          ENDP

                  |L5.112|
                          DCD      0x40051020
                  |L5.116|
                          DCD      ||.data||
                  |L5.120|
                          DCD      0x40004840
                  |L5.124|
                          DCD      0x00002710
                  |L5.128|
                          DCD      FlagSwitch
                  |L5.132|
                          DCD      ||.constdata||
                  |L5.136|
000088  2573203a          DCB      "%s : %4d"
00008c  20253464
                  |L5.144|
000090  0d0a00            DCB      "\r\n",0
000093  00                DCB      0
                  |L5.148|
000094  61646472          DCB      "addr : 0x%2X\r\n",0
000098  203a2030
00009c  78253258
0000a0  0d0a00  
0000a3  00                DCB      0

                          AREA ||i.UART0_Init||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  UART0_Init PROC
;;;118    
;;;119    void UART0_Init(void)
000000  b510              PUSH     {r4,lr}
;;;120    {
;;;121        SYS_ResetModule(UART0_RST);
000002  4816              LDR      r0,|L6.92|
000004  f7fffffe          BL       SYS_ResetModule
;;;122    
;;;123        /* Configure UART0 and set UART0 baud rate */
;;;124        UART_Open(UART0, 115200);
000008  4c15              LDR      r4,|L6.96|
00000a  21e1              MOVS     r1,#0xe1
00000c  0249              LSLS     r1,r1,#9
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       UART_Open
;;;125    
;;;126    	/* Set UART receive time-out */
;;;127    	UART_SetTimeoutCnt(UART0, 20);
000014  2114              MOVS     r1,#0x14
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       UART_SetTimeoutCnt
;;;128    
;;;129    	printf("\r\nCLK_GetCPUFreq : %8d\r\n",CLK_GetCPUFreq());
00001c  f7fffffe          BL       CLK_GetCPUFreq
000020  4601              MOV      r1,r0
000022  a010              ADR      r0,|L6.100|
000024  f7fffffe          BL       __2printf
;;;130    	printf("CLK_GetHXTFreq : %8d\r\n",CLK_GetHXTFreq());
000028  f7fffffe          BL       CLK_GetHXTFreq
00002c  4601              MOV      r1,r0
00002e  a014              ADR      r0,|L6.128|
000030  f7fffffe          BL       __2printf
;;;131    	printf("CLK_GetLXTFreq : %8d\r\n",CLK_GetLXTFreq());	
000034  f7fffffe          BL       CLK_GetLXTFreq
000038  4601              MOV      r1,r0
00003a  a017              ADR      r0,|L6.152|
00003c  f7fffffe          BL       __2printf
;;;132    	printf("CLK_GetPCLK0Freq : %8d\r\n",CLK_GetPCLK0Freq());
000040  f7fffffe          BL       CLK_GetPCLK0Freq
000044  4601              MOV      r1,r0
000046  a01a              ADR      r0,|L6.176|
000048  f7fffffe          BL       __2printf
;;;133    	printf("CLK_GetPCLK1Freq : %8d\r\n",CLK_GetPCLK1Freq());	
00004c  f7fffffe          BL       CLK_GetPCLK1Freq
000050  4601              MOV      r1,r0
000052  a01e              ADR      r0,|L6.204|
000054  f7fffffe          BL       __2printf
;;;134    }
000058  bd10              POP      {r4,pc}
;;;135    
                          ENDP

00005a  0000              DCW      0x0000
                  |L6.92|
                          DCD      0x04000010
                  |L6.96|
                          DCD      0x40070000
                  |L6.100|
000064  0d0a434c          DCB      "\r\nCLK_GetCPUFreq : %8d\r\n",0
000068  4b5f4765
00006c  74435055
000070  46726571
000074  203a2025
000078  38640d0a
00007c  00      
00007d  00                DCB      0
00007e  00                DCB      0
00007f  00                DCB      0
                  |L6.128|
000080  434c4b5f          DCB      "CLK_GetHXTFreq : %8d\r\n",0
000084  47657448
000088  58544672
00008c  6571203a
000090  20253864
000094  0d0a00  
000097  00                DCB      0
                  |L6.152|
000098  434c4b5f          DCB      "CLK_GetLXTFreq : %8d\r\n",0
00009c  4765744c
0000a0  58544672
0000a4  6571203a
0000a8  20253864
0000ac  0d0a00  
0000af  00                DCB      0
                  |L6.176|
0000b0  434c4b5f          DCB      "CLK_GetPCLK0Freq : %8d\r\n",0
0000b4  47657450
0000b8  434c4b30
0000bc  46726571
0000c0  203a2025
0000c4  38640d0a
0000c8  00      
0000c9  00                DCB      0
0000ca  00                DCB      0
0000cb  00                DCB      0
                  |L6.204|
0000cc  434c4b5f          DCB      "CLK_GetPCLK1Freq : %8d\r\n",0
0000d0  47657450
0000d4  434c4b31
0000d8  46726571
0000dc  203a2025
0000e0  38640d0a
0000e4  00      
0000e5  00                DCB      0
0000e6  00                DCB      0
0000e7  00                DCB      0

                          AREA ||i.convertDecToBin||, CODE, READONLY, ALIGN=2

                  convertDecToBin PROC
;;;15     
;;;16     void convertDecToBin(int n)
000000  b5f1              PUSH     {r0,r4-r7,lr}
;;;17     {
000002  b082              SUB      sp,sp,#8
;;;18     	int k = 0;
000004  2500              MOVS     r5,#0
;;;19     	unsigned char *p = (unsigned char*)&n;
000006  a802              ADD      r0,sp,#8
;;;20     	int val2 = 0;
;;;21     	int i = 0;
;;;22     	for(k = 0; k <= 1; k++)
;;;23     	{
;;;24     		val2 = *(p+k);
;;;25     		for (i = 7; i >= 0; i--)
;;;26     		{
;;;27     			if(val2 & (1 << i))
000008  2701              MOVS     r7,#1
00000a  9000              STR      r0,[sp,#0]
                  |L7.12|
00000c  9800              LDR      r0,[sp,#0]            ;24
00000e  2407              MOVS     r4,#7                 ;25
000010  5d46              LDRB     r6,[r0,r5]            ;24
                  |L7.18|
000012  4638              MOV      r0,r7
000014  40a0              LSLS     r0,r0,r4
000016  4230              TST      r0,r6
000018  d001              BEQ      |L7.30|
;;;28     				printf("1");
00001a  a007              ADR      r0,|L7.56|
00001c  e000              B        |L7.32|
                  |L7.30|
;;;29     			else
;;;30     				printf("0");
00001e  a007              ADR      r0,|L7.60|
                  |L7.32|
000020  f7fffffe          BL       __2printf
000024  1e64              SUBS     r4,r4,#1
000026  d5f4              BPL      |L7.18|
;;;31     		}
;;;32     		printf(" ");
000028  a005              ADR      r0,|L7.64|
00002a  f7fffffe          BL       __2printf
00002e  1c6d              ADDS     r5,r5,#1
000030  2d01              CMP      r5,#1                 ;22
000032  ddeb              BLE      |L7.12|
;;;33     	}
;;;34     }
000034  bdfe              POP      {r1-r7,pc}
;;;35     
                          ENDP

000036  0000              DCW      0x0000
                  |L7.56|
000038  3100              DCB      "1",0
00003a  00                DCB      0
00003b  00                DCB      0
                  |L7.60|
00003c  3000              DCB      "0",0
00003e  00                DCB      0
00003f  00                DCB      0
                  |L7.64|
000040  2000              DCB      " ",0
000042  00                DCB      0
000043  00                DCB      0

                          AREA ||i.main||, CODE, READONLY, ALIGN=1

                  main PROC
;;;187    
;;;188    int main()
000000  f7fffffe          BL       SYS_Init
;;;189    {
;;;190        SYS_Init();
;;;191    
;;;192        UART0_Init();
000004  f7fffffe          BL       UART0_Init
;;;193    
;;;194    	GPIO_Init();
000008  f7fffffe          BL       GPIO_Init
;;;195    	
;;;196        I2C0_Init();
00000c  f7fffffe          BL       I2C0_Init
;;;197    	
;;;198    	TIMER3_Init();	
000010  f7fffffe          BL       TIMER3_Init
;;;199    
;;;200    	SetupLIS3DH();
000014  f7fffffe          BL       SetupLIS3DH
                  |L8.24|
;;;201    
;;;202        /* Got no where to go, just loop forever */
;;;203        while(1)
;;;204        {
;;;205    		GetDataLIS3DH();
000018  f7fffffe          BL       GetDataLIS3DH
;;;206    		Angle_Calculate();
00001c  f7fffffe          BL       Angle_Calculate
000020  e7fa              B        |L8.24|
;;;207        }
;;;208    }
;;;209    
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  __FUNCTION__
000000  544d5233          DCB      0x54,0x4d,0x52,0x33
000004  5f495251          DCB      0x5f,0x49,0x52,0x51
000008  48616e64          DCB      0x48,0x61,0x6e,0x64
00000c  6c657200          DCB      0x6c,0x65,0x72,0x00

                          AREA ||.data||, DATA, ALIGN=2

                  ||CNT||
000000  0000              DCW      0x0000
                  CNT_SWITCH
000002  0000              DCW      0x0000
                  LOG
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\main.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_260f81be____REV16|
#line 388 "..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___6_main_c_260f81be____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_260f81be____REVSH|
#line 402
|__asm___6_main_c_260f81be____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

                  __ARM_use_no_argv EQU 0
